## **三大特性**  
### **访问权限**  
c++通过 public、protected、private 三个关键字来控制成员变量和成员函数的访问权限，他们分别表示公有的、受保护的、私有的，被称为成员访问限定符。  

在类的内部（定义类的代码内部），无论成员被声明为public、protected、private，都是可以相互访问的，没有访问权限的限制。  

在类的外部（定义类的代码外部），只能通过对象访问成员，并且通过对象只能访问public属性的成员，不能访问private、protected属性属性的成员。  

无论公有继承、私有和保护继承，私有成员不能被“派生类”访问，基类中的公有和保护成员能被“派生类”访问。  

对于公有继承，只有基类中的公有成员能被派生类对象访问，保护和私有成员不能被派生类对象访问。对于私有和保护继承，基类这的所有成员不能被派生类对象访问。  

### **继承**  

**定义**  
让某种类型对象获得另一个类型对象的属性和方法  

**功能**  
它可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。  

**常见的继承有三种方式**  

1. 实现继承：指使用基类的属性和方法而无需额外编码的能力。  
2. 接口继承：指仅使用属性和方法名称，但是子类提供实现的能力。  
3. 可视继承：指子类使用基类的外观和实现代码的能力。  

### **封装**  

**定义**  
数据和代码捆绑在一起，避免外界干扰和不确定性访问;  

**功能**  
把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏，例如：将公共的数据火方法使用public修饰，而不希望被访问的数据或方法采用private修饰。  

### **多态**  

**定义**  
将同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接受时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态）。  

**功能**  
多态性是允许你将父类对象设置成为和一个或更多的他的子类对象相等的计数，赋值之后，父对象就可以根据当前赋值给他的子对象的特训以不同的方式运作。  
简单的一句话：允许将子类类型的指针赋值给父类类型的指针。  

**实现多态的两种方式**  
1. 覆盖（override）：是将子类重新定义父类的虚函数的做法  
2. 重载（overload）：是指允许存在多个同名函数，而这些函数的参数列表不同（或许参数个数不同，或许参数类型不同，或许两种都有）。  

**虚函数**  
当基类希望派生类定义适合自己的版本，就将这些函数声明为虚函数（virtual）  
虚函数依赖虚函数表工作，表存放虚函数地址，当我们使用基类指针指向派生类时，虚表指针指向派生类的虚函数表（虚函数表大小为4）。这个机制可以保证派生类的虚函数被调用到。  

**1. 虚函数是动态绑定的**  
也就是说使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数，这就是虚函数的基本功能。  

**2. 多态（不同继承关系的类对象，调用同一函数参数不同行为）**  
1. 调用函数的对象必须是指针或者引用  
2. 别调用的函数必须是虚函数（virtual），且完成了虚函数的重写（派生类中有一个跟基类的完全相同虚函数）  

**3. 动态绑定的是动态类型**  
所对应的函数或属性依赖于对象的动态类型，发生在运行期。  

**4. 构造函数不能是虚函数**  
而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好，多态是被disable的。  

**5. 虚函数的工作方式**  
依赖虚函数表工作的，表来保存虚函数地址，当我们使用基类指针指向派生类时，虚表指针vptr指向派生类的虚函数表。这个机制可以保证派生类中的虚函数被调用到。  

**6. 析构函数可以是虚函数，而且在一个复杂类结构中，往往是必须的**  

**7. 将一个函数定义为纯虚函数**  
实际上是将这个类定义为抽象类，不能实例化对象；纯虚函数通常没有定义体，但也完全可以拥有。  

**8. inline、static、constructor三种函数都不能带有virtual关键字**  
1. inline是在编译时展开，必须要有实体。
内联函数是指在编译期间用被调函数体本身来替代函数的调用指令，但虚函数的多态特性需要在运行时根据对象类型才知道调用那个虚函数，所以没法再编译时进行内联函数的展开。
2. static属于class自己的类相关，必须要有实体  

static成员是没有this指针的。virtual函数一定要通过对象来调用，有隐藏的this指针，实例相关。  

**9. 析构函数可以是纯虚的**  
但纯虚函数必须要有定义体，因为析构函数的调用在子类中隐含的。  

**10. 派生类的override虚函数定义必须和父类完全一致**  
除了一个特例，如果父类中返回值是一个指针或引用，子类override时可以返回这个指针（或引用）的派生。  

**为什么需要虚继承**  

1. 为了解决多继承时的命令冲突和冗余数据问题  
c++提出了虚继承，是的派生类中只保留一份间接基类的成员。其中多继承是指多个直接基类中产生派生类的能力，多继承的派生类继承了所有父类的成员。  
2. 虚继承的目的是让某个类做出声明，承若愿意共享他的基类  
其中，这个被共享的基类就称为虚基类（Virtual Base Class），其中A 就是⼀个虚基类。在这种机制下，不论虚基类在继承体系中出现了多少次，在派⽣类中都只包含⼀份虚基类的成员。类A为虚基类，B，C虚继承A，D继承与C、C。类 A 有⼀个成员变量a，不使⽤虚继承，那么在类 D 中直接访问 a 就会产⽣歧义。编译器不知道它究竟来⾃ A -->B-->D 这条路径，还是来⾃ A-->C-->D 这条路。  
C++标准库中的 iostream 类就是⼀个虚继承的实际应⽤案例。
iostream 从 istream 和 ostream 直接继承⽽来，⽽ istream 和 ostream ⼜都继承⾃⼀个共同的名为 baseios 的类，是典型的菱形继承。此时 istream 和 ostream 必须采⽤虚继承，否则将导致 iostream 类中保留两份baseios 类的成员。  
使⽤多继承经常出现⼆义性，必须⼗分⼩⼼；⼀般只有在⽐较简单和不易出现⼆义性或者实在必要情况下才使⽤多继承，能⽤单⼀继承解决问题就不要⽤多继承。  

### **空类**

## **为何空类的大小不是0**  
为了确保两个不同对像的地址是不同的，必须如此。  
类的实例化是在内存中分配一块地址，每个实例在内存中都有独一无二的地址。  
同样，空类也会实例化，所以编译器会给空类隐含的添加一个字节，这样空类实例化后就有独一无二的地址了。  
所以空类的sizeof为1，而不是0。  

```  
    class A{virtual void f(){}};  
    class B:public A{}  
```  
此时，类A和类B都不是空类，其sizeof都是4，因为他们都具有虚函数表的地址。  
```  
    class A{};  
    class B: public virtual A{};  
```  
此时A是空类大小为1，B不是空类，其大小为4，因为含有指向虚基类的指针。  
多重继承的空类大小也是1.  
```  
    class father1{};  
    class father2{};  
    class child:public father1, father2{};  
```  
他们的sizeof都是1.  
何时共享虚函数地址表：如果派⽣类继承的第⼀个是基类，且该基类定义了虚函数地址表，则派⽣类就共享该表⾸址占⽤的存储单元。对于除前述情形以外的其他任何情形，派⽣类在处理完所有基类或虚基类后，根据派⽣类是否建⽴了虚函数地址表，确定是否为该表⾸址分配存储单元。  
```  
    class X{}; //sizeof(X):1  
    class Y : public virtual X {}; //sizeof(Y):4  
    class Z : public virtual X {}; //sizeof(Z):4  
    class A : public virtual Y {}; //sizeof(A):8  
    class B : public Y, public Z{}; //sizeof(B):8  
    class C : public virtual Y, public virtual Z {}; //sizeof(C):12  
    class D : public virtual C{}; //sizeof(D):16  
```  

### **抽象类与接口的实现**  
接口描述了类的行为和功能，而不需要完成类的特定实现；c++接口是使用抽象类来实现的。  
1. 类中至少有一个函数被声明为纯虚函数，而这个类就是抽象类。纯虚函数是通过在声明中使用“=0”来指定的。  
2. 设计抽象类（通常称为ABC）的目的，是为了给其它类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，他只能作为接口使用。   
